"""
Classificateur am√©lior√© combinant approche s√©mantique et patterns existants
Int√©gration avec le syst√®me existant pour une transition en douceur
"""

from typing import Dict, List, Tuple, Optional, Any
import json
import os
from datetime import datetime

from .semantic_classifier import SemanticHubHeroHelpClassifier
from .database import classify_video_with_language, detect_language

class EnhancedHubHeroHelpClassifier:
    """
    Classificateur hybride combinant:
    1. Compr√©hension s√©mantique (embeddings)
    2. Patterns traditionnels (fallback)
    3. Apprentissage continu
    """
    
    def __init__(self, 
                 semantic_model: str = "sentence-transformers/all-MiniLM-L6-v2",
                 enable_semantic: bool = True,
                 semantic_weight: float = 0.7):
        """
        Initialise le classificateur hybride
        
        Args:
            semantic_model: Mod√®le sentence-transformers √† utiliser
            enable_semantic: Active/d√©sactive la classification s√©mantique
            semantic_weight: Poids de la classification s√©mantique (0.0-1.0)
        """
        self.enable_semantic = enable_semantic
        self.semantic_weight = semantic_weight
        self.traditional_weight = 1.0 - semantic_weight
        
        print(f"[ENHANCED] üöÄ Initialisation du classificateur hybride")
        print(f"[ENHANCED] üß† S√©mantique: {'‚úÖ Activ√©e' if enable_semantic else '‚ùå D√©sactiv√©e'}")
        print(f"[ENHANCED] ‚öñÔ∏è  Poids s√©mantique: {semantic_weight:.1%}")
        
        # Initialisation du classificateur s√©mantique
        if self.enable_semantic:
            try:
                self.semantic_classifier = SemanticHubHeroHelpClassifier(semantic_model)
                print(f"[ENHANCED] ‚úÖ Classificateur s√©mantique initialis√©")
            except Exception as e:
                print(f"[ENHANCED] ‚ùå Erreur classificateur s√©mantique: {e}")
                print(f"[ENHANCED] üîÑ Basculement vers mode traditionnel uniquement")
                self.enable_semantic = False
        
        # Statistiques d'utilisation
        self.classification_stats = {
            'total_classifications': 0,
            'semantic_used': 0,
            'traditional_used': 0,
            'hybrid_used': 0,
            'accuracy_feedback': []
        }
    
    def classify_content(self, 
                        title: str, 
                        description: str = "",
                        use_traditional_fallback: bool = True) -> Dict[str, Any]:
        """
        Classifie un contenu avec l'approche hybride
        
        Args:
            title: Titre du contenu
            description: Description du contenu
            use_traditional_fallback: Utiliser le syst√®me traditionnel en fallback
            
        Returns:
            Dict contenant la classification compl√®te
        """
        result = {
            'title': title,
            'description': description,
            'timestamp': datetime.now().isoformat(),
            'methods_used': [],
            'final_category': None,
            'confidence': 0,
            'details': {}
        }
        
        self.classification_stats['total_classifications'] += 1
        
        # 1. Classification s√©mantique (si activ√©e)
        semantic_result = None
        if self.enable_semantic:
            try:
                category, confidence, details = self.semantic_classifier.classify_text(title, description)
                semantic_result = {
                    'category': category,
                    'confidence': confidence,
                    'details': details
                }
                result['methods_used'].append('semantic')
                result['details']['semantic'] = semantic_result
                self.classification_stats['semantic_used'] += 1
                
                print(f"[ENHANCED] üß† S√©mantique: {category.upper()} ({confidence:.1f}%)")
                
            except Exception as e:
                print(f"[ENHANCED] ‚ùå Erreur classification s√©mantique: {e}")
                semantic_result = None
        
        # 2. Classification traditionnelle (si fallback activ√©)
        traditional_result = None
        if use_traditional_fallback:
            try:
                category, detected_language, confidence = classify_video_with_language(title, description)
                traditional_result = {
                    'category': category,
                    'confidence': confidence,
                    'language': detected_language
                }
                result['methods_used'].append('traditional')
                result['details']['traditional'] = traditional_result
                self.classification_stats['traditional_used'] += 1
                
                print(f"[ENHANCED] üìù Traditionnel: {category.upper()} ({confidence:.1f}%)")
                
            except Exception as e:
                print(f"[ENHANCED] ‚ùå Erreur classification traditionnelle: {e}")
                traditional_result = None
        
        # 3. Combinaison des r√©sultats
        final_category, final_confidence = self._combine_results(semantic_result, traditional_result)
        
        result['final_category'] = final_category
        result['confidence'] = final_confidence
        
        # D√©termination de la m√©thode utilis√©e
        if semantic_result and traditional_result:
            self.classification_stats['hybrid_used'] += 1
            result['method'] = 'hybrid'
            print(f"[ENHANCED] ‚öñÔ∏è  Hybride: {final_category.upper()} ({final_confidence:.1f}%)")
        elif semantic_result:
            result['method'] = 'semantic_only'
            print(f"[ENHANCED] üß† S√©mantique seule: {final_category.upper()} ({final_confidence:.1f}%)")
        elif traditional_result:
            result['method'] = 'traditional_only'
            print(f"[ENHANCED] üìù Traditionnel seul: {final_category.upper()} ({final_confidence:.1f}%)")
        else:
            result['method'] = 'fallback'
            result['final_category'] = 'hub'
            result['confidence'] = 50
            print(f"[ENHANCED] üîÑ Fallback: HUB (50%)")
        
        return result
    
    def _combine_results(self, semantic_result: Optional[Dict], traditional_result: Optional[Dict]) -> Tuple[str, float]:
        """
        Combine les r√©sultats s√©mantique et traditionnel
        
        Args:
            semantic_result: R√©sultat de la classification s√©mantique
            traditional_result: R√©sultat de la classification traditionnelle
            
        Returns:
            Tuple[str, float]: (cat√©gorie_finale, confiance_finale)
        """
        if semantic_result and traditional_result:
            # Mode hybride: pond√©ration des deux approches
            
            # Si les deux m√©thodes sont d'accord, boost de confiance
            if semantic_result['category'] == traditional_result['category']:
                return semantic_result['category'], min(95, 
                    (semantic_result['confidence'] * self.semantic_weight + 
                     traditional_result['confidence'] * self.traditional_weight) + 10)
            
            # Si en d√©saccord, utiliser la m√©thode avec la plus forte confiance
            if semantic_result['confidence'] >= traditional_result['confidence']:
                return semantic_result['category'], semantic_result['confidence'] * self.semantic_weight
            else:
                return traditional_result['category'], traditional_result['confidence'] * self.traditional_weight
        
        elif semantic_result:
            return semantic_result['category'], semantic_result['confidence']
        
        elif traditional_result:
            return traditional_result['category'], traditional_result['confidence']
        
        else:
            return 'hub', 50  # Fallback par d√©faut
    
    def add_feedback(self, title: str, description: str, correct_category: str, user_notes: str = ""):
        """
        Ajoute un feedback utilisateur pour am√©liorer la classification
        
        Args:
            title: Titre du contenu
            description: Description du contenu
            correct_category: Cat√©gorie correcte selon l'utilisateur
            user_notes: Notes additionnelles
        """
        # Ajout √† la classification s√©mantique
        if self.enable_semantic:
            self.semantic_classifier.add_example(title, correct_category, description)
        
        # Enregistrement du feedback
        feedback = {
            'timestamp': datetime.now().isoformat(),
            'title': title,
            'description': description,
            'correct_category': correct_category,
            'user_notes': user_notes
        }
        
        self.classification_stats['accuracy_feedback'].append(feedback)
        
        print(f"[ENHANCED] ‚úÖ Feedback ajout√©: {correct_category.upper()} pour '{title[:50]}...'")
    
    def get_explanation(self, title: str, description: str = "") -> Dict:
        """
        Obtient une explication d√©taill√©e de la classification
        
        Args:
            title: Titre du contenu
            description: Description du contenu
            
        Returns:
            Dict: Explication compl√®te de la classification
        """
        explanation = {
            'content': {'title': title, 'description': description},
            'semantic_explanation': None,
            'traditional_explanation': None,
            'final_reasoning': None
        }
        
        # Explication s√©mantique
        if self.enable_semantic:
            try:
                semantic_explanation = self.semantic_classifier.explain_classification(title, description)
                explanation['semantic_explanation'] = semantic_explanation
            except Exception as e:
                explanation['semantic_explanation'] = f"Erreur: {e}"
        
        # Classification traditionnelle pour comparaison
        try:
            category, language, confidence = classify_video_with_language(title, description)
            explanation['traditional_explanation'] = {
                'category': category,
                'confidence': confidence,
                'language': language,
                'method': 'pattern_matching'
            }
        except Exception as e:
            explanation['traditional_explanation'] = f"Erreur: {e}"
        
        # Raisonnement final
        result = self.classify_content(title, description)
        explanation['final_reasoning'] = {
            'final_category': result['final_category'],
            'confidence': result['confidence'],
            'method': result['method'],
            'reasoning': self._generate_final_reasoning(result)
        }
        
        return explanation
    
    def _generate_final_reasoning(self, result: Dict) -> str:
        """
        G√©n√®re une explication textuelle du raisonnement final
        """
        method = result['method']
        category = result['final_category']
        confidence = result['confidence']
        
        if method == 'hybrid':
            return f"Classification hybride: combinaison des approches s√©mantique et traditionnelle ‚Üí {category.upper()} ({confidence:.1f}%)"
        elif method == 'semantic_only':
            return f"Classification s√©mantique uniquement: compr√©hension du sens ‚Üí {category.upper()} ({confidence:.1f}%)"
        elif method == 'traditional_only':
            return f"Classification traditionnelle uniquement: matching de patterns ‚Üí {category.upper()} ({confidence:.1f}%)"
        else:
            return f"Classification par d√©faut: aucune m√©thode disponible ‚Üí {category.upper()} ({confidence:.1f}%)"
    
    def get_stats(self) -> Dict:
        """
        Retourne les statistiques d'utilisation du classificateur
        """
        total = self.classification_stats['total_classifications']
        if total == 0:
            return {'message': 'Aucune classification effectu√©e'}
        
        return {
            'total_classifications': total,
            'method_usage': {
                'semantic': f"{self.classification_stats['semantic_used']} ({self.classification_stats['semantic_used']/total:.1%})",
                'traditional': f"{self.classification_stats['traditional_used']} ({self.classification_stats['traditional_used']/total:.1%})",
                'hybrid': f"{self.classification_stats['hybrid_used']} ({self.classification_stats['hybrid_used']/total:.1%})"
            },
            'configuration': {
                'semantic_enabled': self.enable_semantic,
                'semantic_weight': self.semantic_weight,
                'traditional_weight': self.traditional_weight
            },
            'feedback_received': len(self.classification_stats['accuracy_feedback'])
        }
    
    def save_configuration(self, filepath: str):
        """
        Sauvegarde la configuration et les statistiques
        """
        config = {
            'enable_semantic': self.enable_semantic,
            'semantic_weight': self.semantic_weight,
            'traditional_weight': self.traditional_weight,
            'stats': self.classification_stats,
            'created_at': datetime.now().isoformat()
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
        
        print(f"[ENHANCED] üíæ Configuration sauvegard√©e: {filepath}")


def demonstrate_enhanced_classifier():
    """
    D√©monstration du classificateur am√©lior√©
    """
    print("\n" + "="*60)
    print("üéØ D√âMONSTRATION DU CLASSIFICATEUR AM√âLIOR√â")
    print("="*60)
    
    # Initialisation
    classifier = EnhancedHubHeroHelpClassifier(
        semantic_weight=0.8,  # Favoriser l'approche s√©mantique
        enable_semantic=True
    )
    
    # Tests de classification
    test_contents = [
        {
            'title': "Nouveau spa exclusif √† Club Med Bali",
            'description': "D√©couvrez en avant-premi√®re notre nouveau spa de luxe avec des soins in√©dits inspir√©s de la tradition balinaise"
        },
        {
            'title': "Comment r√©server votre s√©jour en ligne",
            'description': "Guide complet pour effectuer votre r√©servation sur notre site web en quelques clics"
        },
        {
            'title': "Destination France - Episode 5: La Provence",
            'description': "Cinqui√®me √©pisode de notre s√©rie sur les destinations fran√ßaises, focus sur la r√©gion proven√ßale"
        }
    ]
    
    for i, content in enumerate(test_contents, 1):
        print(f"\nüß™ Test {i}:")
        print(f"üìù Titre: {content['title']}")
        print(f"üìÑ Description: {content['description']}")
        
        # Classification
        result = classifier.classify_content(content['title'], content['description'])
        
        # Explication
        explanation = classifier.get_explanation(content['title'], content['description'])
        
        print(f"üéØ R√©sultat: {result['final_category'].upper()} ({result['confidence']:.1f}%)")
        print(f"üîß M√©thode: {result['method']}")
        print(f"üí≠ Explication: {explanation['final_reasoning']['reasoning']}")
        
        if explanation['semantic_explanation']:
            print(f"üß† S√©mantique: {explanation['semantic_explanation']['reasoning']}")
    
    # Statistiques
    print(f"\nüìä Statistiques:")
    stats = classifier.get_stats()
    print(f"üî¢ Total classifications: {stats['total_classifications']}")
    print(f"üìà Utilisation des m√©thodes: {stats['method_usage']}")
    
    print("\n" + "="*60)
    print("üèÅ FIN DE LA D√âMONSTRATION")
    print("="*60)


if __name__ == "__main__":
    demonstrate_enhanced_classifier() 